/*
selects the <take> best options, skips the first <skip> best options, based on the three highest criteria
*/

export function getBest(skip, take, session, db){
    const filtered = filter(session, db); 
    //this is where the matching starts

    // maybe less than take to escape the bubble
    matchBestMOnNPreferences(take, skip, 5, session, db);
}

function matchBestMOnNPreferences(take,skip, N, session, db){
    const {filters, preferences} = session;
    const sortedPreferences = sortMapDesc(preferences);
    console.log(sortedPreferences);             // debuggin

    const highestNPreferences = sortedPreferences.slice(0, N);
    let weigthed = {}; // map of key:value = meal:userWeight
    db.forEach( p => {
        const tags = p['tags'];
        let sum = 0;
        tags.forEach( x => {
            if(sortedPreferences.get(x)) {
                sum += sortedPreferences.get(x);
            }
        })
        weigthed.set(p, sum)
    });
    const highestMeals = sortMapDesc(weigthed);
    return highestMeals.slice(skip, take);               // nehmen der [skip : skip+take] besten meals 

}

function sortMapDesc(inputMap) {
    return new Map([...inputMap.entries()].sort((a, b) => b[1] - a[1]));
}

function filter(session, db){
    const filtered = []; 

    db.forEach((recipe) => {
        let conflict = false;  
        session.filters.forEach((filter) => {
            if(!recipe[tags].includes(filter)){
                conflict = true; 
            }
        }); 
        if(!conflict){
            filtered.push(recipe); 
        }
    }); 
    return filtered; 
}